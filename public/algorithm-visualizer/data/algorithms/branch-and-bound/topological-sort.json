{
  "algorithm": {
    "categoryKey": "branch-and-bound",
    "categoryName": "Branch and Bound",
    "algorithmKey": "topological-sort",
    "algorithmName": "Topological Sort",
    "files": [
      {
        "name": "README.md",
        "content": "# Topological Sort\n\nIn the field of computer science, a topological sort or\ntopological ordering of a directed graph is a linear ordering\nof its vertices such that for every directed edge `uv` from\nvertex `u` to vertex `v`, `u` comes before `v` in the ordering.\n\nFor instance, the vertices of the graph may represent tasks to\nbe performed, and the edges may represent constraints that one\ntask must be performed before another; in this application, a\ntopological ordering is just a valid sequence for the tasks.\n\nA topological ordering is possible if and only if the graph has\nno directed cycles, that is, if it is a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph)\n(DAG). Any DAG has at least one topological ordering, and algorithms are\nknown for constructing a topological ordering of any DAG in linear time.\n\n![Directed Acyclic Graph](https://upload.wikimedia.org/wikipedia/commons/c/c6/Topological_Ordering.svg)\n\nA topological ordering of a directed acyclic graph: every edge goes from\nearlier in the ordering (upper left) to later in the ordering (lower right).\nA directed graph is acyclic if and only if it has a topological ordering.\n\n## Example\n\n![Topologic Sorting](https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg)\n\nThe graph shown above has many valid topological sorts, including:\n\n- `5, 7, 3, 11, 8, 2, 9, 10` (visual left-to-right, top-to-bottom)\n- `3, 5, 7, 8, 11, 2, 9, 10` (smallest-numbered available vertex first)\n- `5, 7, 3, 8, 11, 10, 9, 2` (fewest edges first)\n- `7, 5, 11, 3, 10, 8, 9, 2` (largest-numbered available vertex first)\n- `5, 7, 11, 2, 3, 8, 9, 10` (attempting top-to-bottom, left-to-right)\n- `3, 7, 8, 5, 11, 10, 2, 9` (arbitrary)\n\n## Application\n\nThe canonical application of topological sorting is in\n**scheduling a sequence of jobs** or tasks based on their dependencies. The jobs\nare represented by vertices, and there is an edge from `x` to `y` if\njob `x` must be completed before job `y` can be started (for\nexample, when washing clothes, the washing machine must finish\nbefore we put the clothes in the dryer). Then, a topological sort\ngives an order in which to perform the jobs.\n\nOther application is **dependency resolution**. Each vertex is a package\nand each edge is a dependency of package `a` on package 'b'. Then topological\nsorting will provide a sequence of installing dependencies in a way that every\nnext dependency has its dependent packages to be installed in prior.\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/topological-sorting)\n- [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting)\n- [Topological Sorting on YouTube by Tushar Roy](https://www.youtube.com/watch?v=ddTC4Zovtbc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// G[i][j] indicates whether the path from the i-th node to the j-th node exists or not. NOTE: The graph must be Directed-Acyclic\nconst G = [\n  [0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0],\n  [1, 0, 0, 1, 0, 0],\n  [1, 1, 0, 0, 0, 0],\n];\n\n// define tracer variables {\nconst tracer = new GraphTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\ntracer.set(G);\nTracer.delay();\n// }\n\nconst inDegrees = Array(...Array(G.length)).map(Number.prototype.valueOf, 0); // create an Array of G.length number of 0s\nconst Q = [];\nlet iter = 0;\nlet i;\n\n// logger {\nlogger.println('Calculating in-degrees for each Node...');\n// }\n\nfor (let currNode = 0; currNode < G.length; currNode++) {\n  for (let currNodeNeighbor = 0; currNodeNeighbor < G.length; currNodeNeighbor++) {\n    if (G[currNode][currNodeNeighbor]) {\n      // visualize {\n      logger.println(`${currNodeNeighbor} has an incoming edge from ${currNode}`);\n      tracer.visit(currNodeNeighbor, currNode);\n      Tracer.delay();\n      // }\n      inDegrees[currNodeNeighbor]++;\n      // visualize {\n      tracer.leave(currNodeNeighbor, currNode);\n      Tracer.delay();\n      // }\n    }\n  }\n}\n// logger {\nlogger.println(`Done. In-Degrees are: [ ${String(inDegrees)} ]`);\nlogger.println('');\n\nlogger.println('Initializing queue with all the sources (nodes with no incoming edges)');\n// }\ninDegrees.map((indegrees, node) => {\n  // visualize {\n  tracer.visit(node);\n  Tracer.delay();\n  // }\n  if (!indegrees) {\n    // logger {\n    logger.println(`${node} is a source`);\n    // }\n    Q.push(node);\n  }\n  // visualize {\n  tracer.leave(node);\n  Tracer.delay();\n  // }\n});\n// logger {\nlogger.println(`Done. Initial State of Queue: [ ${String(Q)} ]`);\nlogger.println('');\n// }\n\n// begin topological sort (kahn)\nwhile (Q.length > 0) {\n  // logger {\n  logger.println(`Iteration #${iter}. Queue state: [ ${String(Q)} ]`);\n  // }\n  const currNode = Q.shift();\n  // visualize {\n  tracer.visit(currNode);\n  Tracer.delay();\n  // }\n\n  for (i = 0; i < G.length; i++) {\n    if (G[currNode][i]) {\n      // visualize {\n      logger.println(`${i} has an incoming edge from ${currNode}. Decrementing ${i}'s in-degree by 1.`);\n      tracer.visit(i, currNode);\n      Tracer.delay();\n      // }\n      inDegrees[i]--;\n      // visualize {\n      tracer.leave(i, currNode);\n      Tracer.delay();\n      // }\n\n      if (!inDegrees[i]) {\n        // logger {\n        logger.println(`${i}'s in-degree is now 0. Enqueuing ${i}`);\n        // }\n        Q.push(i);\n      }\n    }\n  }\n  // visualize {\n  tracer.leave(currNode);\n  Tracer.delay();\n  // }\n  // logger {\n  logger.println(`In-degrees are: [${String(inDegrees)} ]`);\n  logger.println('-------------------------------------------------------------------');\n  // }\n  \n  iter++;\n}\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "In the field of computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering."
  }
}