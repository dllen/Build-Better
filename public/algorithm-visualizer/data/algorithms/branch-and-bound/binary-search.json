{
  "algorithm": {
    "categoryKey": "branch-and-bound",
    "categoryName": "Branch and Bound",
    "algorithmKey": "binary-search",
    "algorithmName": "Binary Search",
    "files": [
      {
        "name": "README.md",
        "content": "# Binary Search\n\nIn computer science, binary search, also known as half-interval\nsearch, logarithmic search, or binary chop, is a search algorithm\nthat finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle\nelement of the array; if they are unequal, the half in which\nthe target cannot lie is eliminated and the search continues\non the remaining half until it is successful. If the search\nends with the remaining half being empty, the target is not\nin the array.\n\n![Binary Search](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg)\n\n## Complexity\n\n**Time Complexity**: `O(log(n))` - since we split search area by two for every\nnext iteration.\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search)\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n- [YouTube](https://www.youtube.com/watch?v=P3YID7liBug&index=29&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "iterative.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15, value: () => Randomize.Integer({ min: 0, max: 50 }), sorted: true });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\nfunction BinarySearch(array, element) { // array = sorted array, element = element to be found\n  let minIndex = 0;\n  let maxIndex = array.length - 1;\n  let testElement;\n\n  while (minIndex <= maxIndex) {\n    const middleIndex = Math.floor((minIndex + maxIndex) / 2);\n    testElement = array[middleIndex];\n\n    // visualize {\n    tracer.select(minIndex, maxIndex);\n    Tracer.delay();\n    tracer.patch(middleIndex);\n    logger.println(`Searching at index: ${middleIndex}`);\n    Tracer.delay();\n    tracer.depatch(middleIndex);\n    tracer.deselect(minIndex, maxIndex);\n    // }\n\n    if (testElement < element) {\n      // logger {\n      logger.println('Going right.');\n      // }\n      minIndex = middleIndex + 1;\n    } else if (testElement > element) {\n      // logger {\n      logger.println('Going left.');\n      // }\n      maxIndex = middleIndex - 1;\n    } else {\n      // visualize {\n      logger.println(`${element} is found at position ${middleIndex}!`);\n      tracer.select(middleIndex);\n      // }\n\n      return middleIndex;\n    }\n  }\n\n  // logger {\n  logger.println(`${element} is not found!`);\n  // }\n  return -1;\n}\n\nconst element = D[Randomize.Integer({ min: 0, max: D.length - 1 })];\n\n// logger {\nlogger.println(`Using iterative binary search to find ${element}`);\n// }\nBinarySearch(D, element);\n",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "voronoipotato",
            "avatar_url": "https://avatars.githubusercontent.com/u/315863?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      },
      {
        "name": "recursive.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15, value: () => Randomize.Integer({ min: 0, max: 50 }), sorted: true });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\nfunction BinarySearch(array, element, minIndex, maxIndex) { // array = sorted array, element = element to be found, minIndex = low index, maxIndex = high index\n  if (minIndex > maxIndex) {\n    // logger {\n    logger.println(`${element} is not found!`);\n    // }\n    return -1;\n  }\n\n  const middleIndex = Math.floor((minIndex + maxIndex) / 2);\n  const testElement = array[middleIndex];\n\n  // visualize {\n  tracer.select(minIndex, maxIndex);\n  Tracer.delay();\n  tracer.patch(middleIndex);\n  logger.println(`Searching at index: ${middleIndex}`);\n  Tracer.delay();\n  tracer.depatch(middleIndex);\n  tracer.deselect(minIndex, maxIndex);\n  // }\n\n  if (testElement < element) {\n    // logger {\n    logger.println('Going right.');\n    // }\n    return BinarySearch(array, element, middleIndex + 1, maxIndex);\n  }\n\n  if (testElement > element) {\n    // logger {\n    logger.println('Going left.');\n    // }\n    return BinarySearch(array, element, minIndex, middleIndex - 1);\n  }\n\n  if (testElement === element) {\n    // visualize {\n    logger.println(`${element} is found at position ${middleIndex}!`);\n    tracer.select(middleIndex);\n    // }\n    return middleIndex;\n  }\n\n  // logger {\n  logger.println(`${element} is not found!`);\n  // }\n  return -1;\n}\n\nconst element = D[Randomize.Integer({ min: 0, max: D.length - 1 })];\n\n// logger {\nlogger.println(`Using binary search to find ${element}`);\n// }\nBinarySearch(D, element, 0, D.length - 1);\n",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Web-Engine",
            "avatar_url": "https://avatars.githubusercontent.com/u/3965510?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "In computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array; if they are unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with the remaining half being empty, the target is not in the array."
  }
}