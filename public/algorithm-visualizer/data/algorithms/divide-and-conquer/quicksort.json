{
  "algorithm": {
    "categoryKey": "divide-and-conquer",
    "categoryName": "Divide and Conquer",
    "algorithmKey": "quicksort",
    "algorithmName": "Quicksort",
    "files": [
      {
        "name": "Code.java",
        "content": "import org.algorithm_visualizer.*;\n\nimport java.util.Arrays;\n\nclass Main {\n\n    private static ChartTracer chartTracer = new ChartTracer();\n\n    private static LogTracer logTracer = new LogTracer(\"Console\");\n\n    private static Array1DTracer tracer = new Array1DTracer();\n\n    private static Integer[] array = (Integer[]) new Randomize.Array1D(15, new Randomize.Integer(1, 20)).create();\n\n    public static void main(String[] args) {\n        tracer.set(array);\n        tracer.chart(chartTracer);\n        Layout.setRoot(new VerticalLayout(new Commander[]{chartTracer, tracer, logTracer}));\n        logTracer.printf(\"original array = %s\\n\", Arrays.toString(array));\n\n        Tracer.delay();\n        quickSort(array, 0, array.length - 1);\n        logTracer.printf(\"sorted array = %s\\n\", Arrays.toString(array));\n    }\n\n    public static void quickSort(Integer[] arr, int left, int right) {\n        int l, r, s;\n        while (right > left) {\n            l = left;\n            r = right;\n            s = arr[left];\n            while (l < r) {\n                tracer.select(left);\n                tracer.select(right);\n                Tracer.delay();\n                while (arr[r] > s) {\n                    tracer.select(r);\n                    Tracer.delay();\n                    tracer.deselect(r);\n                    r--;\n                }\n                arr[l] = arr[r];\n                tracer.patch(l, arr[r]);\n                Tracer.delay();\n                tracer.depatch(l);\n                while (s >= arr[l] && l < r) {\n                    tracer.select(l);\n                    Tracer.delay();\n                    tracer.deselect(l);\n                    l++;\n                }\n                arr[r] = arr[l];\n                tracer.patch(r, arr[l]);\n                Tracer.delay();\n                tracer.depatch(r);\n                tracer.deselect(left);\n                tracer.deselect(right);\n            }\n            arr[l] = s;\n            tracer.patch(l, s);\n            Tracer.delay();\n            tracer.depatch(l);\n            quickSort(arr, left, l - 1);\n            left = l + 1;\n        }\n    }\n\n}\n",
        "contributors": []
      },
      {
        "name": "README.md",
        "content": "# Quicksort\n\nQuicksort is a divide and conquer algorithm.\nQuicksort first divides a large array into two smaller\nsub-arrays: the low elements and the high elements.\nQuicksort can then recursively sort the sub-arrays\n\nThe steps are:\n\n1. Pick an element, called a pivot, from the array.\n2. Partitioning: reorder the array so that all elements with\nvalues less than the pivot come before the pivot, while all\nelements with values greater than the pivot come after it\n(equal values can go either way). After this partitioning,\nthe pivot is in its final position. This is called the\npartition operation.\n3. Recursively apply the above steps to the sub-array of\nelements with smaller values and separately to the\nsub-array of elements with greater values.\n\nAnimated visualization of the quicksort algorithm.\nThe horizontal lines are pivot values.\n\n![Quicksort](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | No        |  Quicksort is usually done in-place with O(log(n)) stack space |\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort)\n- [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)\n- [YouTube](https://www.youtube.com/watch?v=SLauY6PpjW4&index=28&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15 });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\n// logger {\nlogger.println(`original array = [${D.join(', ')}]`);\n// }\n\nfunction partition(D, low, high) {\n  let i;\n  let j;\n  let s;\n  while (high > low) {\n    i = low;\n    j = high;\n    s = D[low];\n    while (i < j) {\n      // visualize {\n      tracer.select(high);\n      tracer.select(low);\n      Tracer.delay();\n      // }\n      while (D[j] > s) {\n        // visualize {\n        tracer.select(j);\n        Tracer.delay();\n        tracer.deselect(j);\n        // }\n        j--;\n      }\n      D[i] = D[j];\n      // visualize {\n      tracer.patch(i, D[j]);\n      Tracer.delay();\n      tracer.depatch(i);\n      // }\n      while (s >= D[i] && i < j) {\n        // visualize {\n        tracer.select(i);\n        Tracer.delay();\n        tracer.deselect(i);\n        // }\n        i++;\n      }\n      D[j] = D[i];\n      // visualize {\n      tracer.patch(j, D[i]);\n      Tracer.delay();\n      tracer.depatch(j);\n      tracer.deselect(high);\n      tracer.deselect(low);\n      // }\n    }\n    D[i] = s;\n    // visualize {\n    tracer.patch(i, s);\n    Tracer.delay();\n    tracer.depatch(i);\n    // }\n    partition(D, low, i - 1);\n    low = i + 1;\n  }\n}\n\nfunction quicksort(D) {\n  partition(D, 0, D.length - 1);\n}\n\nquicksort(D);\n// logger {\nlogger.println(`sorted array = [${D.join(', ')}]`);\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "imkimchi",
            "avatar_url": "https://avatars.githubusercontent.com/u/13452168?v=4"
          },
          {
            "login": "TornjV",
            "avatar_url": "https://avatars.githubusercontent.com/u/13820300?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays"
  }
}