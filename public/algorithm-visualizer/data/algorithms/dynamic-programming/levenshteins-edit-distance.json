{
  "algorithm": {
    "categoryKey": "dynamic-programming",
    "categoryName": "Dynamic Programming",
    "algorithmKey": "levenshteins-edit-distance",
    "algorithmName": "Levenshtein's Edit Distance",
    "files": [
      {
        "name": "README.md",
        "content": "# Levenshtein's Edit Distance\n\nThe Levenshtein distance is a string metric for measuring the\ndifference between two sequences. Informally, the Levenshtein\ndistance between two words is the minimum number of\nsingle-character edits (insertions, deletions or substitutions)\nrequired to change one word into the other.\n\n## Definition\n\nMathematically, the Levenshtein distance between two strings\n`a` and `b` (of length `|a|` and `|b|` respectively) is given by\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/4cf357d8f2135035207088d2c7b890fb4b64e410)\nwhere\n\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/f0a48ecfc9852c042382fdc33c19e11a16948e85)\n\nwhere\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/52512ede08444b13838c570ba4a3fc71d54dbce9)\nis the indicator function equal to `0` when\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/231fda9ee578f0328c5ca28088d01928bb0aaaec)\nand equal to 1 otherwise, and\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/bdc0315678caad28648aafedb6ebafb16bd1655c)\nis the distance between the first `i` characters of `a` and the first\n`j` characters of `b`.\n\nNote that the first element in the minimum corresponds to\ndeletion (from `a` to `b`), the second to insertion and\nthe third to match or mismatch, depending on whether the\nrespective symbols are the same.\n\n## Example\n\nFor example, the Levenshtein distance between `kitten` and\n`sitting` is `3`, since the following three edits change one\ninto the other, and there is no way to do it with fewer than\nthree edits:\n\n1. **k**itten → **s**itten (substitution of \"s\" for \"k\")\n2. sitt**e**n → sitt**i**n (substitution of \"i\" for \"e\")\n3. sittin → sittin**g** (insertion of \"g\" at the end).\n\n## Applications\n\nThis has a wide range of applications, for instance, spell checkers, correction\nsystems for optical character recognition, fuzzy string searching, and software\nto assist natural language translation based on translation memory.\n\n## Dynamic Programming Approach Explanation\n\nLet’s take a simple example of finding minimum edit distance between\nstrings `ME` and `MY`. Intuitively you already know that minimum edit distance\nhere is `1` operation and this operation. And it is replacing `E` with `Y`. But\nlet’s try to formalize it in a form of the algorithm in order to be able to\ndo more complex examples like transforming `Saturday` into `Sunday`.\n\nTo apply the mathematical formula mentioned above to `ME → MY` transformation\nwe need to know minimum edit distances of `ME → M`, `M → MY` and `M → M` transformations\nin prior. Then we will need to pick the minimum one and add _one_ operation to\ntransform last letters `E → Y`. So minimum edit distance of `ME → MY` transformation\nis being calculated based on three previously possible transformations.\n\nTo explain this further let’s draw the following matrix:\n\n![Levenshtein Matrix](https://cdn-images-1.medium.com/max/1600/1*aTunSUoy0BJyYBVn4tWGrA.png)\n\n- Cell `(0:1)` contains red number 1. It means that we need 1 operation to\ntransform `M` to an empty string. And it is by deleting `M`. This is why this number is red.\n- Cell `(0:2)` contains red number 2. It means that we need 2 operations\nto transform `ME` to an empty string. And it is by deleting `E` and `M`.\n- Cell `(1:0)` contains green number 1. It means that we need 1 operation\nto transform an empty string to `M`. And it is by inserting `M`. This is why this number is green.\n- Cell `(2:0)` contains green number 2. It means that we need 2 operations\nto transform an empty string to `MY`. And it is by inserting `Y` and  `M`.\n- Cell `(1:1)` contains number 0. It means that it costs nothing\nto transform `M` into `M`.\n- Cell `(1:2)` contains red number 1. It means that we need 1 operation\nto transform `ME` to `M`. And it is by deleting `E`.\n- And so on...\n\nThis looks easy for such small matrix as ours (it is only `3x3`). But here you\nmay find basic concepts that may be applied to calculate all those numbers for\nbigger matrices (let’s say a `9x7` matrix for `Saturday → Sunday` transformation).\n\nAccording to the formula you only need three adjacent cells `(i-1:j)`, `(i-1:j-1)`, and `(i:j-1)` to\ncalculate the number for current cell `(i:j)`. All we need to do is to find the\nminimum of those three cells and then add `1` in case if we have different\nletters in `i`'s row and `j`'s column.\n\nYou may clearly see the recursive nature of the problem.\n\n![Levenshtein Matrix](https://cdn-images-1.medium.com/max/1600/1*w8UB4DSvBnAK6mBXRGQDjw.png)\n\nLet's draw a decision graph for this problem.\n\n![Minimum Edit Distance Decision Graph](https://cdn-images-1.medium.com/max/1600/1*8jD0qvr5B9PwRFM_9z7q9A.png)\n\nYou may see a number of overlapping sub-problems on the picture that are marked\nwith red. Also there is no way to reduce the number of operations and make it\nless than a minimum of those three adjacent cells from the formula.\n\nAlso you may notice that each cell number in the matrix is being calculated\nbased on previous ones. Thus the tabulation technique (filling the cache in\nbottom-up direction) is being applied here.\n\nApplying this principle further we may solve more complicated cases like\nwith `Saturday → Sunday` transformation.\n\n![Levenshtein distance](https://cdn-images-1.medium.com/max/1600/1*geMdmZcdU1bZbHIoh6KO3Q.png)\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance)\n- [Wikipedia](https://en.wikipedia.org/wiki/Levenshtein_distance)\n- [YouTube](https://www.youtube.com/watch?v=We3YDTzNXEk&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [ITNext](https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe)\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst str1 = 'stack';\nconst str2 = 'racket';\nconst table = new Array(str1.length + 1);\n\nfor (let i = 0; i < str1.length + 1; i++) {\n  table[i] = new Array(str2.length + 1).fill(-1);\n  table[i][0] = i;\n}\nfor (let i = 1; i < str2.length + 1; i++) {\n  table[0][i] = i;\n}\n\n// define tracer variables {\nconst tracer = new Array2DTracer('Distance Table');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.set(table);\nTracer.delay();\n// }\n\n// logger {\nlogger.println('Initialized DP Table');\nlogger.println(`Y-Axis (Top to Bottom): ${str1}`);\nlogger.println(`X-Axis (Left to Right): ${str2}`);\n// }\n\nconst dist = (function editDistance(str1, str2, table) {\n  // display grid with words\n  // logger {\n  logger.println(`*** ${str2.split('').join(' ')}`);\n  table.forEach((item, index) => {\n    const character = (index === 0) ? '*' : str1[index - 1];\n    logger.println(`${character}\\t${item}`);\n  });\n  // }\n\n  // begin ED execution\n  for (let i = 1; i < str1.length + 1; i++) {\n    for (let j = 1; j < str2.length + 1; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        // visualize {\n        tracer.select(i - 1, j - 1);\n        Tracer.delay();\n        // }\n        table[i][j] = table[i - 1][j - 1];\n        // visualize {\n        tracer.patch(i, j, table[i][j]);\n        Tracer.delay();\n        tracer.depatch(i, j);\n        tracer.deselect(i - 1, j - 1);\n        // }\n      } else {\n        // visualize {\n        tracer.select(i - 1, j);\n        tracer.select(i, j - 1);\n        tracer.select(i - 1, j - 1);\n        Tracer.delay();\n        // }\n        table[i][j] = Math.min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1]) + 1;\n        // visualize {\n        tracer.patch(i, j, table[i][j]);\n        Tracer.delay();\n        tracer.depatch(i, j);\n        tracer.deselect(i - 1, j);\n        tracer.deselect(i, j - 1);\n        tracer.deselect(i - 1, j - 1);\n        // }\n      }\n    }\n  }\n\n  // visualize {\n  tracer.select(str1.length, str2.length);\n  // }\n  return table[str1.length][str2.length];\n}(str1, str2, table));\n\n// logger {\nlogger.println(`Minimum Edit Distance: ${dist}`);\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "The Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other."
  }
}