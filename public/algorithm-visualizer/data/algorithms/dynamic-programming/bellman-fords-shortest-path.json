{
  "algorithm": {
    "categoryKey": "dynamic-programming",
    "categoryName": "Dynamic Programming",
    "algorithmKey": "bellman-fords-shortest-path",
    "algorithmName": "Bellman-Ford's Shortest Path",
    "files": [
      {
        "name": "README.md",
        "content": "# Bellman-Ford's Shortest Path\n\nThe Bellman–Ford algorithm is an algorithm that computes shortest\npaths from a single source vertex to all of the other vertices\nin a weighted digraph. It is slower than Dijkstra's algorithm\nfor the same problem, but more versatile, as it is capable of\nhandling graphs in which some of the edge weights are negative\nnumbers.\n\n![Bellman-Ford](https://upload.wikimedia.org/wikipedia/commons/2/2e/Shortest_path_Dijkstra_vs_BellmanFord.gif)\n\n## Complexity\n\nWorst-case performance `O(|V||E|)`\nBest-case performance\t`O(|E|)`\nWorst-case space complexity `O(|V|)`\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford)\n- [Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\n- [On YouTube by Michael Sambol](https://www.youtube.com/watch?v=obWXjtg0L64&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "PFischbeck",
            "avatar_url": "https://avatars.githubusercontent.com/u/2820802?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst tracer = new GraphTracer().weighted();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\nconst G = Randomize.Graph({ N: 5, ratio: .5, value: () => Randomize.Integer({ min: -2, max: 5 }), weighted: true });\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction BELLMAN_FORD(src, dest) {\n  const weights = new Array(G.length);\n  let i;\n  let j;\n\n  for (i = 0; i < G.length; i++) {\n    weights[i] = MAX_VALUE;\n    // visualize {\n    tracer.updateNode(i, weights[i]);\n    // }\n  }\n  weights[src] = 0;\n  // visualize {\n  tracer.updateNode(src, 0);\n  // }\n\n  // logger {\n  logger.println(`Initializing weights to: [${weights}]`);\n  logger.println('');\n  // }\n\n  // begin BF algorithm execution\n  let k = G.length;\n  while (k--) {\n    // logger {\n    logger.println(`Iteration: ${G.length - k}`);\n    logger.println('------------------------------------------------------------------');\n    // }\n\n    for (i = 0; i < G.length; i++) {\n      for (j = 0; j < G.length; j++) {\n        if (G[i][j]) { // proceed to relax Edges only if a particular weight !== 0 (0 represents no edge)\n          if (weights[j] > (weights[i] + G[i][j])) {\n            weights[j] = weights[i] + G[i][j];\n            // logger {\n            logger.println(`weights[${j}] = weights[${i}] + ${G[i][j]}`);\n            // }\n          }\n          // visualize {\n          tracer.visit(j, i, weights[j]);\n          Tracer.delay();\n          tracer.leave(j, i);\n          Tracer.delay();\n          // }\n        }\n      }\n    }\n\n    // logger {\n    logger.println(`updated weights: [${weights.join(', ')}]`);\n    logger.println('');\n    // }\n  }\n\n  // check for cycle\n  logger.println('checking for cycle');\n  for (i = 0; i < G.length; i++) {\n    for (j = 0; j < G.length; j++) {\n      if (G[i][j]) {\n        if (weights[j] > (weights[i] + G[i][j])) {\n          // logger {\n          logger.println(`A cycle was detected: weights[${j}] > weights[${i}] + ${G[i][j]}`);\n          // }\n          return (MAX_VALUE);\n        }\n      }\n    }\n  }\n\n  // logger {\n  logger.println(`No cycles detected. Final weights for the source ${src} are: [${weights}]`);\n  // }\n\n  return weights[dest];\n}\n\nconst src = Randomize.Integer({ min: 0, max: G.length - 1 });\nlet dest;\nlet MAX_VALUE = 0x7fffffff;\nlet minWeight;\n\n/*\n src = start node\n dest = start node (but will eventually at as the end node)\n */\n\ndo {\n  dest = Randomize.Integer({ min: 0, max: G.length - 1 });\n}\nwhile (src === dest);\n\n// logger {\nlogger.println(`finding the shortest path from ${src} to ${dest}`);\n// }\n\nminWeight = BELLMAN_FORD(src, dest);\n\n// logger {\nif (minWeight === MAX_VALUE) {\n  logger.println(`there is no path from ${src} to ${dest}`);\n} else {\n  logger.println(`the shortest path from ${src} to ${dest} is ${minWeight}`);\n}\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers."
  }
}