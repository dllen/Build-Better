{
  "algorithm": {
    "categoryKey": "dynamic-programming",
    "categoryName": "Dynamic Programming",
    "algorithmKey": "longest-common-subsequence",
    "algorithmName": "Longest Common Subsequence",
    "files": [
      {
        "name": "README.md",
        "content": "# Longest Common Subsequence\n\nThe longest common subsequence (LCS) problem is the problem of finding\nthe longest subsequence common to all sequences in a set of sequences\n(often just two sequences). It differs from the longest common substring\nproblem: unlike substrings, subsequences are not required to occupy\nconsecutive positions within the original sequences.\n\n## Application\n\nThe longest common subsequence problem is a classic computer science\nproblem, the basis of data comparison programs such as the diff utility,\nand has applications in bioinformatics. It is also widely used by\nrevision control systems such as Git for reconciling multiple changes\nmade to a revision-controlled collection of files.\n\n## Example\n\n- LCS for input Sequences `ABCDGH` and `AEDFHR` is `ADH` of length 3.\n- LCS for input Sequences `AGGTAB` and `GXTXAYB` is `GTAB` of length 4.\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-common-subsequence)\n- [Wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)\n- [YouTube](https://www.youtube.com/watch?v=NnD96abizww&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst string1 = 'AGGTAB';\nconst string2 = 'GXTXAYB';\nconst m = string1.length;\nconst n = string2.length;\nconst A = new Array(m + 1);\nfor (let i = 0; i < m + 1; i++) {\n  A[i] = new Array(n + 1);\n}\n\n// define tracer variables {\nconst tracer1 = new Array1DTracer('String 1');\nconst tracer2 = new Array1DTracer('String 2');\nconst tracer3 = new Array2DTracer('Memo Table');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer1, tracer2, tracer3, logger]));\ntracer1.set(string1);\ntracer2.set(string2);\ntracer3.set(A);\nTracer.delay();\n// }\n\nlet i;\nlet j;\n\n// Build the memo table in bottom up fashion\nfor (i = 0; i <= m; i++) {\n  for (j = 0; j <= n; j++) {\n    if (i === 0 || j === 0) {\n      A[i][j] = 0;\n    } else if (string1[i - 1] === string2[j - 1]) {\n      // visualize {\n      tracer1.select(i - 1);\n      Tracer.delay();\n      tracer2.select(j - 1);\n      Tracer.delay();\n      tracer3.select(i - 1, j - 1);\n      Tracer.delay();\n      // }\n\n      A[i][j] = A[i - 1][j - 1] + 1;\n\n      // visualize {\n      tracer1.deselect(i - 1);\n      tracer2.deselect(j - 1);\n      tracer3.deselect(i - 1, j - 1);\n      // }\n    } else {\n      // visualize {\n      tracer3.select(i - 1, j);\n      Tracer.delay();\n      tracer3.select(i, j - 1);\n      Tracer.delay();\n      // }\n\n      if (A[i - 1][j] > A[i][j - 1]) {\n        A[i][j] = A[i - 1][j];\n      } else {\n        A[i][j] = A[i][j - 1];\n      }\n\n      // visualize {\n      tracer3.deselect(i - 1, j);\n      tracer3.deselect(i, j - 1);\n      // }\n    }\n    // visualize {\n    tracer3.patch(i, j, A[i][j]);\n    Tracer.delay();\n    tracer3.depatch(i, j);\n    // }\n  }\n}\n\nlet finalString = '';\ni = m;\nj = n;\nwhile (i >= 1 && j >= 1) {\n  // visualize {\n  tracer3.select(i, j);\n  Tracer.delay();\n  // }\n  if (string1[i - 1] === string2[j - 1]) {\n    // visualize {\n    tracer1.select(i - 1);\n    Tracer.delay();\n    tracer2.select(j - 1);\n    Tracer.delay();\n    // }\n\n    finalString = string1[i - 1] + finalString;\n    i--;\n    j--;\n  } else if (A[i - 1][j] > A[i][j - 1]) {\n    i--;\n  } else {\n    j--;\n  }\n}\n\n// logger {\nlogger.println(`Longest Common Subsequence Length is ${A[m][n]}`);\nlogger.println(`Longest Common Subsequence is ${finalString}`);\n// }\n",
        "contributors": [
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences."
  }
}