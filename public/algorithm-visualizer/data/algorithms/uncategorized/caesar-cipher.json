{
  "algorithm": {
    "categoryKey": "uncategorized",
    "categoryName": "Uncategorized",
    "algorithmKey": "caesar-cipher",
    "algorithmName": "Caesar Cipher",
    "files": [
      {
        "name": "README.md",
        "content": "# Caesar Cipher\nIn cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, Caesar's code or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence.\n\n## Applications\n* Often incorporated as part of more complex schemes, such as the VigenÃ¨re cipher\n\n## Complexity\n* **Time**: best O(N * #ofRotations), worst O(N * #ofRotations * alphabetSize)\n* **Space**: best O(1), worst O(alphabetSize)\n\n## References\n* [Wikipedia](https://en.wikipedia.org/wiki/Caesar_cipher)",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst string = 'hello! how are you doing?';\nconst rotation = 5;\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz';\n// create a map of char -> position to improve run time\n// otherwise we would have to search the alphabet each\n// time to find the character position\nconst alphabetMap = alphabet.split('').reduce((map, curr, idx) => {\n  map[curr] = idx;\n  return map;\n}, {});\n\n// define tracer variables {\nconst encryptTracer = new Array1DTracer('Encryption');\nconst decryptTracer = new Array1DTracer('Decryption');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([encryptTracer, decryptTracer, logger]));\n\nencryptTracer.set(string);\nTracer.delay();\n// }\n\nfunction getPosUp(pos) {\n  return (pos === alphabet.length - 1) ? 0 : pos + 1;\n}\n\nfunction getPosDown(pos) {\n  return (pos === 0) ? alphabet.length - 1 : pos - 1;\n}\n\nfunction getNextChar(currChar, direction) {\n  const pos = alphabetMap[currChar];\n  const nextPos = direction === 'up' ? getPosUp(pos) : getPosDown(pos);\n  const nextChar = alphabet.charAt(nextPos);\n\n  // logger {\n  logger.println(`${currChar} -> ${nextChar}`);\n  // }\n  return nextChar;\n}\n\nfunction cipher(str, rotation, direction, cipherTracer) {\n  if (!str) return '';\n\n  for (let i = 0; i < str.length; i++) {\n    // visualize {\n    Tracer.delay();\n    // }\n\n    let currChar = str.charAt(i);\n    if (typeof alphabetMap[currChar] === 'number') { // don't encrpt/decrypt characters not in  alphabetMap\n      let r = rotation;\n\n      // logger {\n      logger.println(`Rotating ${currChar} ${direction} ${rotation} times`);\n      // }\n      // visualize {\n      cipherTracer.select(i);\n      Tracer.delay();\n      // }\n\n      // perform given amount of rotations in the given direction\n      while (r-- > 0) {\n        currChar = getNextChar(currChar, direction);\n        // visualize {\n        cipherTracer.patch(i, currChar);\n        Tracer.delay();\n        // }\n      }\n    } else {\n      // logger {\n      logger.println('Ignore this character');\n      // }\n    }\n    str = str.substring(0, i) + currChar + str.substring(i + 1);\n    // logger {\n    logger.println(`Current result: ${str}`);\n    // }\n  }\n\n  return str;\n}\n\nfunction encrypt(str, rotation) {\n  // logger {\n  logger.println(`Encrypting: ${str}`);\n  // }\n  return cipher(str, rotation, 'up', encryptTracer);\n}\n\nfunction decrypt(str, rotation) {\n  // logger {\n  logger.println(`Decrypting: ${str}`);\n  // }\n  return cipher(str, rotation, 'down', decryptTracer);\n}\n\nconst encrypted = encrypt(string, rotation);\n// logger {\nlogger.println(`Encrypted result: ${encrypted}`);\n// }\n\ndecryptTracer.set(encrypted);\nconst decrypted = decrypt(encrypted, rotation);\n// logger {\nlogger.println(`Decrypted result: ${decrypted}`);\n// }\n",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "In cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, Caesar's code or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence."
  }
}