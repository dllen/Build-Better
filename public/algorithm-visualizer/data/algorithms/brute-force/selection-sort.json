{
  "algorithm": {
    "categoryKey": "brute-force",
    "categoryName": "Brute Force",
    "algorithmKey": "selection-sort",
    "algorithmName": "Selection Sort",
    "files": [
      {
        "name": "README.md",
        "content": "# Selection Sort\n\nSelection sort is a sorting algorithm, specifically an\nin-place comparison sort. It has O(n2) time complexity,\nmaking it inefficient on large lists, and generally\nperforms worse than the similar insertion sort.\nSelection sort is noted for its simplicity, and it has\nperformance advantages over more complicated algorithms\nin certain situations, particularly where auxiliary\nmemory is limited.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Selection sort**    | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1         | No        |           |\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/selection-sort)\n- [Wikipedia](https://en.wikipedia.org/wiki/Selection_sort)\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          }
        ]
      },
      {
        "name": "code.java",
        "content": "import org.algorithm_visualizer.*;\n\nimport java.util.Arrays;\n\npublic class Main {\n\n    private static ChartTracer chartTracer = new ChartTracer();\n\n    private static LogTracer logTracer = new LogTracer(\"Console\");\n\n    private static Integer [] array = (Integer[]) new Randomize.Array1D(15, new Randomize.Integer(1, 20)).create();\n\n    public static void main(String[] args) {\n        int length = array.length;\n        Layout.setRoot(new VerticalLayout(new Commander[]{chartTracer, logTracer}));\n        logTracer.printf(\"original array = %s\\n\", Arrays.toString(array));\n        chartTracer.set(array);\n        Tracer.delay();\n        int minIndex;\n\n        for (int i = 0; i < length; i++) {\n            chartTracer.select(i);\n            Tracer.delay();\n            minIndex = i;\n            for (int j = i + 1; j < length; j++){\n                chartTracer.select(j);\n                Tracer.delay();\n                if(array[j] < array[minIndex]) {\n                    chartTracer.patch(j, array[j]);\n                    Tracer.delay();\n                    chartTracer.depatch(j);\n                    minIndex = j;\n                }\n                chartTracer.deselect(j);\n            }\n            swap(minIndex, i, array);\n            chartTracer.deselect(i);\n        }\n\n        logTracer.printf(\"sorted array = %s\\n\", Arrays.toString(array));\n    }\n\n\n    private static void swap(int x, int y, Integer[] array) {\n        int temp = array[x];\n        array[x] = array[y];\n        array[y] = temp;\n        chartTracer.patch(x, array[x]);\n        chartTracer.patch(y, array[y]);\n        Tracer.delay();\n        chartTracer.depatch(x);\n        chartTracer.depatch(y);\n    }\n\n}\n",
        "contributors": []
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15 });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\n// logger {\nlogger.println(`original array = [${D.join(', ')}]`);\n// }\nfor (let i = 0; i < D.length - 1; i++) {\n  let minJ = i;\n  // visualize {\n  tracer.select(i);\n  Tracer.delay();\n  // }\n  for (let j = i + 1; j < D.length; j++) {\n    // visualize {\n    tracer.select(j);\n    Tracer.delay();\n    // }\n    if (D[j] < D[minJ]) {\n      minJ = j;\n      // visualize {\n      tracer.patch(j);\n      Tracer.delay();\n      tracer.depatch(j);\n      // }\n    }\n    // visualize {\n    tracer.deselect(j);\n    // }\n  }\n  if (minJ !== i) {\n    // logger {\n    logger.println(`swap ${D[i]} and ${D[minJ]}`);\n    // }\n    const temp = D[i];\n    D[i] = D[minJ];\n    D[minJ] = temp;\n    // visualize {\n    tracer.patch(i, D[i]);\n    tracer.patch(minJ, D[minJ]);\n    Tracer.delay();\n    tracer.depatch(i);\n    tracer.depatch(minJ);\n    // }\n  }\n  // visualize {\n  tracer.deselect(i);\n  // }\n}\n// logger {\nlogger.println(`sorted array = [${D.join(', ')}]`);\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "TornjV",
            "avatar_url": "https://avatars.githubusercontent.com/u/13820300?v=4"
          },
          {
            "login": "alpgcosta",
            "avatar_url": "https://avatars.githubusercontent.com/u/16641046?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "Selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited."
  }
}