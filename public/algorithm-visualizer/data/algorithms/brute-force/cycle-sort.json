{
  "algorithm": {
    "categoryKey": "brute-force",
    "categoryName": "Brute Force",
    "algorithmKey": "cycle-sort",
    "algorithmName": "Cycle Sort",
    "files": [
      {
        "name": "README.md",
        "content": "# Cycle Sort\nCycle sort is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm. It is based on the idea that the permutation to be sorted can be factored into cycles, which can individually be rotated to give a sorted result.\n\n## Complexity\n* **Time**: worst ![](https://latex.codecogs.com/svg.latex?O(n^2)), best ![](https://latex.codecogs.com/svg.latex?O(n^2)), average ![](https://latex.codecogs.com/svg.latex?O(n^2))\n* **Space**: worst ![](https://latex.codecogs.com/svg.latex?O(1)) auxiliary\n\n## References\n* [Wikipedia](https://en.wikipedia.org/wiki/Cycle_sort)",
        "contributors": [
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15 });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\n// logger {\nlogger.println(`original array = [${D.join(', ')}]`);\n// }\nconst N = D.length;\nlet writes = 0; // number of writing performed\nlet pos; // the index of item in the sorted array\nlet item; // an item in the array\nlet temp; // a temp value used for storing swapped item\nfor (let cycleStart = 0; cycleStart <= N - 2; cycleStart++) {\n  item = D[cycleStart];\n\n  // find where to put the item\n  pos = cycleStart;\n  // visualize {\n  tracer.select(cycleStart);\n  // }\n\n  for (let i = cycleStart + 1; i <= N - 1; i++) {\n    // visualize {\n    tracer.select(i);\n    Tracer.delay();\n    tracer.deselect(i);\n    // }\n    if (D[i] < item) {\n      pos++;\n    }\n  }\n\n  // if the item is already there, this is not a circle\n  if (pos === cycleStart) {\n    // visualize {\n    tracer.deselect(cycleStart);\n    // }\n    continue;\n  }\n\n  // otherwise put the item there or right after any duplicates\n  while (item === D[pos]) {\n    pos++;\n  }\n\n  // write item to new index and increment writes\n  temp = D[pos];\n  D[pos] = item;\n  item = temp;\n\n  writes++;\n\n  // logger {\n  if (pos !== cycleStart) {\n    logger.println(`Rewrite ${D[pos]} to index ${pos}; the next value to rewrite is ${item}`);\n  } else {\n    logger.println(`Rewrite ${D[pos]} to index ${pos}`);\n  }\n  // }\n  // visualize {\n  tracer.select(pos);\n  Tracer.delay();\n  tracer.deselect(pos);\n  tracer.patch(pos, D[pos]);\n  tracer.patch(cycleStart, D[cycleStart]);\n  Tracer.delay();\n  tracer.depatch(pos);\n  tracer.depatch(cycleStart);\n  // }\n\n  // rotate the rest of the cycle\n  while (pos !== cycleStart) {\n    pos = cycleStart;\n\n    for (let i = cycleStart + 1; i <= N - 1; i++) {\n      // visualize {\n      tracer.select(i);\n      Tracer.delay();\n      tracer.deselect(i);\n      // }\n      if (D[i] < item) {\n        pos++;\n      }\n    }\n\n    while (item === D[pos]) {\n      pos++;\n    }\n\n    temp = D[pos];\n    D[pos] = item;\n    item = temp;\n\n    // logger {\n    if (pos !== cycleStart) {\n      logger.println(`Rewrite ${D[pos]} to index ${pos}; the next value to rewrite is ${item}`);\n    } else {\n      logger.println(`Rewrite ${D[pos]} to index ${pos}`);\n    }\n    // }\n    // visualize {\n    tracer.select(pos);\n    Tracer.delay();\n    tracer.deselect(pos);\n    tracer.patch(pos, D[pos]);\n    tracer.patch(cycleStart, D[cycleStart]);\n    Tracer.delay();\n    tracer.depatch(pos);\n    tracer.depatch(cycleStart);\n    // }\n\n    writes++;\n  }\n}\n\n// logger {\nlogger.println(`Number of writes performed is ${writes}`);\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Howon",
            "avatar_url": "https://avatars.githubusercontent.com/u/8075728?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "Cycle sort is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm. It is based on the idea that the permutation to be sorted can be factored into cycles, which can individually be rotated to give a sorted result."
  }
}