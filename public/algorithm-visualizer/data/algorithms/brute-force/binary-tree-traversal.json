{
  "algorithm": {
    "categoryKey": "brute-force",
    "categoryName": "Brute Force",
    "algorithmKey": "binary-tree-traversal",
    "algorithmName": "Binary Tree Traversal",
    "files": [
      {
        "name": "README.md",
        "content": "# Binary Tree Traversal\nIn computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited.\n\n## Applications\n* Pre-order traversal while duplicating nodes and edges can make a complete duplicate of a binary tree.\n* Pre-order traversal can also be used to make a prefix expression (Polish notation) from expression trees: traverse the expression tree pre-orderly.\n* In-order traversal is very commonly used on binary search trees because it returns values from the underlying set in order, according to the comparator that set up the binary search tree (hence the name).\n* Post-order traversal while deleting or freeing nodes and values can delete or free an entire binary tree.\n* Post-order traversal can also generate a postfix representation of a binary tree.\n\n## Complexity\n* **Time**: Best : ![](https://latex.codecogs.com/svg.latex?O(N)) Average : ![](https://latex.codecogs.com/svg.latex?O(N)) Worst : ![](https://latex.codecogs.com/svg.latex?O(N))\n* **Space**: Worst: ![](https://latex.codecogs.com/svg.latex?O(N)) (recursive), Best: ![](https://latex.codecogs.com/svg.latex?O(1)) (iterative)\n\n## References\n* [Wikipedia](https://en.wikipedia.org/wiki/Tree_traversal)",
        "contributors": [
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "inOrder.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n];\n\nconst T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child\n  [-1, -1],\n  [0, 2],\n  [-1, -1],\n  [1, 4],\n  [-1, -1],\n  [3, 8],\n  [-1, 7],\n  [-1, -1],\n  [6, 10],\n  [-1, -1],\n  [9, -1],\n];\n\n// define tracer variables {\nconst treeTracer = new GraphTracer('Traversal In-order');\nconst arrayTracer = new Array1DTracer('Print In-order');\nconst logger = new LogTracer('Log');\nLayout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));\ntreeTracer.set(G);\ntreeTracer.layoutTree(5);\narrayTracer.set(new Array(T.length).fill('-'));\nTracer.delay();\n// }\n\nlet index = 0;\n\nfunction inOrder(root, parent) {\n  if (root === -1) {\n    // logger {\n    logger.println('No more nodes. Backtracking.');\n    Tracer.delay();\n    // }\n    return;\n  }\n\n  // visualize {\n  logger.println(`Reached ${root}`);\n  treeTracer.visit(root, parent);\n  Tracer.delay();\n\n  logger.println(` Going left from ${root}`);\n  Tracer.delay();\n  // }\n  inOrder(T[root][0], root);\n\n  // visualize {\n  logger.println(`Printing ${root}`);\n  treeTracer.leave(root);\n  arrayTracer.patch(index++, root);\n  Tracer.delay();\n\n  logger.println(` Going right from ${root}`);\n  Tracer.delay();\n  // }\n  inOrder(T[root][1], root);\n}\n\ninOrder(5); // node with key 5 is the root\n// logger {\nlogger.println('Finished');\n// }\n",
        "contributors": [
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      },
      {
        "name": "postOrder.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n];\n\nconst T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child\n  [-1, -1],\n  [0, 2],\n  [-1, -1],\n  [1, 4],\n  [-1, -1],\n  [3, 8],\n  [-1, 7],\n  [-1, -1],\n  [6, 10],\n  [-1, -1],\n  [9, -1],\n];\n\n// define tracer variables {\nconst treeTracer = new GraphTracer('Traversal Post-order');\nconst arrayTracer = new Array1DTracer('Print Post-order');\nconst logger = new LogTracer('Log');\nLayout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));\ntreeTracer.set(G);\ntreeTracer.layoutTree(5);\narrayTracer.set(new Array(T.length).fill('-'));\nTracer.delay();\n// }\n\nlet index = 0;\n\nfunction postOrder(root, parent) {\n  if (root === -1) {\n    // logger {\n    logger.println('No more nodes. Backtracking.');\n    Tracer.delay();\n    // }\n    return;\n  }\n\n  // visualize {\n  logger.println(`Reached ${root}`);\n  treeTracer.visit(root, parent);\n  Tracer.delay();\n\n  logger.println(` Going left from ${root}`);\n  Tracer.delay();\n  // }\n  postOrder(T[root][0], root);\n\n  // logger {\n  logger.println(` Going right from ${root}`);\n  Tracer.delay();\n  // }\n  postOrder(T[root][1], root);\n\n  // visualize {\n  logger.println(`Printing ${root}`);\n  treeTracer.leave(root);\n  arrayTracer.patch(index++, root);\n  Tracer.delay();\n  // }\n}\n\npostOrder(5); // node with key 5 is the root\n// logger {\nlogger.println('Finished');\n// visualize {\n",
        "contributors": [
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      },
      {
        "name": "preOrder.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n];\n\nconst T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child\n  [-1, -1],\n  [0, 2],\n  [-1, -1],\n  [1, 4],\n  [-1, -1],\n  [3, 8],\n  [-1, 7],\n  [-1, -1],\n  [6, 10],\n  [-1, -1],\n  [9, -1],\n];\n\n// define tracer variables {\nconst treeTracer = new GraphTracer('Traversal Pre-order');\nconst arrayTracer = new Array1DTracer('Print Pre-order');\nconst logger = new LogTracer('Log');\nLayout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));\ntreeTracer.set(G);\ntreeTracer.layoutTree(5);\narrayTracer.set(new Array(T.length).fill('-'));\nTracer.delay();\n// }\n\nlet index = 0;\n\nfunction preOrder(root, parent) {\n  if (root === -1) {\n    // logger {\n    logger.println('No more nodes. Backtracking.');\n    Tracer.delay();\n    // }\n    return;\n  }\n\n  // visualize {\n  logger.println(`Reached ${root}`);\n  treeTracer.visit(root, parent);\n  Tracer.delay();\n\n  logger.println(`Printing ${root}`);\n  treeTracer.leave(root);\n  arrayTracer.patch(index++, root);\n  Tracer.delay();\n\n  logger.println(` Going left from ${root}`);\n  Tracer.delay();\n  // }\n  preOrder(T[root][0], root);\n\n  // logger {\n  logger.println(` Going right from ${root}`);\n  Tracer.delay();\n  // }\n  preOrder(T[root][1], root);\n}\n\npreOrder(5); // node with key 5 is the root\n// logger {\nlogger.println('Finished');\n// }\n",
        "contributors": [
          {
            "login": "archie94",
            "avatar_url": "https://avatars.githubusercontent.com/u/12955150?v=4"
          },
          {
            "login": "nem035",
            "avatar_url": "https://avatars.githubusercontent.com/u/9661806?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "In computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited."
  }
}