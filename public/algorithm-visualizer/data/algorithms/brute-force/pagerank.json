{
  "algorithm": {
    "categoryKey": "brute-force",
    "categoryName": "Brute Force",
    "algorithmKey": "pagerank",
    "algorithmName": "PageRank",
    "files": [
      {
        "name": "README.md",
        "content": "# PageRank\nPageRank is an algorithm used by Google Search to rank websites in their search engine results.<br />Before viewing this visualization, we recommend you give the E-Factory Page a read (link provided under References).<br />The top-most view simulates a mini-internet: a web of connections. A directed edge from A to B means that web Page A provides a link to B. The next view will display the final ranks. We first calculate the no. of links a page has, i.e., its <b>outgoing edges</b> and display in the next view pane.<br />The last visual is an array of arrays. From 0 (top of matrix) down to the Nth Node (bottom), each stores an array of the <b>Nodes pointing to it</b>.<br />For eg-if the first line of Matrix says \"2 3 -1 -1 -1\", it means Web Page 2 and 3 have a link to Web Page 0. The -1s represent null (nothing).<br />The bottom-most view is where you will see the logs as the algorithm progresses.\n\n## Applications\n* Web Page Indexing for refining search results\n\n## Complexity\n* **Time**: worst ![](https://latex.codecogs.com/svg.latex?O(|V|+|E|))\n* **Space**: worst ![](https://latex.codecogs.com/svg.latex?O(|V|))\n\n## References\n* [Princeton university](http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm)\n* [E-Factory](http://pr.efactory.de/e-pagerank-algorithm.shtml)\n",
        "contributors": [
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Array2DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nfunction filledArray(length, value) {\n  return Array(...Array(length)).map(Number.prototype.valueOf, value);\n}\n\n// define tracer variables {\nconst G = Randomize.Graph({ N: 5, ratio: .4 });\nlet ranks;\nconst outgoingEdgeCounts = filledArray(G.length, 0);\nlet incomingNodes;\nconst graphTracer = new GraphTracer('Web Page inter-connections');\nconst rankTracer = new Array1DTracer('Web Page Ranks');\nconst oecTracer = new Array1DTracer('Outgoing Edge Counts');\nconst inTracer = new Array2DTracer('Incoming Nodes');\n\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([graphTracer, rankTracer, oecTracer, inTracer, logger]));\n\ngraphTracer.set(G);\noecTracer.set(outgoingEdgeCounts);\n\nfor (incomingNodes = []; incomingNodes.length < G.length; incomingNodes.push(filledArray(G.length, -1))) ;\ninTracer.set(incomingNodes);\nTracer.delay();\n// }\n\n/*\n  PageRank Algorithm Version 2\n  Equation:\n    PR (X) = ( (1 - D)/N ) + D (Summation i->X (PR (I) / Out (i)))\n  NOTE: Algorithm uses the recommended damping factor (D). Number of iterations is small because only a small Web of 5 Pages is simulated\n*/\n\nfunction arraySum(array) {\n  return array.reduce(\n    (sum, curr) =>\n      sum + (curr ? 1 : 0) // if curr is 0 (no edge) or undefined (loop not allowed), sum remains unchanged\n    , 0,\n  );\n}\n\nfunction showOutgoingEdges(i) {\n  G[i].forEach((edgeExists, j) => {\n    if (edgeExists) {\n      // visualize {\n      graphTracer.visit(j, i);\n      Tracer.delay();\n      graphTracer.leave(j, i);\n      Tracer.delay();\n      // }\n    }\n  });\n}\n\n// PRECOMPUTATIONS\n\n// logger {\nlogger.println('Calculate Outgoing Edge Count for each Node');\n// }\n(function calculateOEC() {\n  G.forEach((relations, i) => {\n    outgoingEdgeCounts[i] = arraySum(relations);\n    showOutgoingEdges(i);\n\n    // visualize {\n    oecTracer.patch(i, outgoingEdgeCounts[i]);\n    Tracer.delay();\n    oecTracer.depatch(i);\n    Tracer.delay();\n    // }\n  });\n}());\n\n// logger {\nlogger.println('determine incoming nodes for each node');\n// }\n(function determineIN() {\n  for (let i = 0; i < G.length; i++) {\n    for (let j = 0; j < G.length; j++) {\n      if (G[i][j]) {\n        // there's an edge FROM i TO j\n        // visualize {\n        graphTracer.visit(j, i);\n        Tracer.delay();\n        // }\n\n        const nextPos = incomingNodes[j].indexOf(-1);\n        incomingNodes[j][nextPos] = i;\n        // visualize {\n        inTracer.patch(j, nextPos, i);\n        Tracer.delay();\n        inTracer.depatch(j, nextPos);\n        Tracer.delay();\n\n        graphTracer.leave(j, i);\n        Tracer.delay();\n        // }\n      }\n    }\n  }\n\n  // logger.println ('All -1s will be removed from incoming node records, they are irrelevant');\n  incomingNodes.forEach((arr) => {\n    arr.splice(arr.indexOf(-1));\n  });\n}());\n\nfunction updateRank(nodeIndex) {\n  let inNodeSummation = 0;\n  let result;\n\n  // logger {\n  logger.println(`Updating rank of ${nodeIndex}`);\n  logger.println(`The incoming Nodes of ${nodeIndex} are being highlighted`);\n  // }\n\n  incomingNodes[nodeIndex].forEach((incoming, i) => {\n    // visualize {\n    inTracer.select(nodeIndex, i);\n    Tracer.delay();\n    logger.println(`Outgoing edge count of ${incoming} is ${outgoingEdgeCounts[incoming]}`);\n    oecTracer.select(incoming);\n    Tracer.delay();\n    // }\n\n    inNodeSummation += (ranks[incoming] / outgoingEdgeCounts[incoming]);\n\n    // visualize {\n    oecTracer.deselect(incoming);\n    Tracer.delay();\n    inTracer.deselect(nodeIndex, i);\n    Tracer.delay();\n    // }\n  });\n  // logger {\n  logger.println(`In-Node summation of ${nodeIndex} = ${inNodeSummation}`);\n  // }\n  \n  result = ((1 - damping) / G.length) + (damping * inNodeSummation); // notice the subtle difference between equations of Basic PR & PR version 2 (divide by N)\n  // logger {\n  logger.println(`Therefore, using Equation, new rank of ${nodeIndex} = ${result}`);\n  // }\n  return result;\n}\n\nlet damping = 0.85;\nlet iterations = 7;\nconst initialRank = 1.0;\n\n// logger {\nlogger.println(`Initialized all Page ranks to ${initialRank}`);\n// }\nranks = filledArray(G.length, initialRank);\n\n// visualize {\nrankTracer.set(ranks);\n// }\n// logger {\nlogger.println('Begin execution of PageRank Version #1');\nlogger.println('Equation used: PR (X) = (1 - D) + D (In-Node-Summation i->X (PR (I) / Out (i)))');\nlogger.println('D = Damping Factor, PR (X) = Page rank of Node X, i = the ith In-Node of X, Out (i) = outgoing Edge Count of i');\nlogger.println('');\n// }\n\nwhile (iterations--) {\n  for (let node = 0; node < ranks.length; node++) {\n    ranks[node] = updateRank(node);\n    // visualize {\n    rankTracer.patch(node, ranks[node]);\n    Tracer.delay();\n    rankTracer.patch(node);\n    Tracer.delay();\n    // }\n  }\n}\n\n// logger {\nlogger.println('Page Ranks have been converged to.');\nranks.forEach((rank, node) => {\n  logger.println(`Rank of Node #${node} = ${rank}`);\n});\nlogger.println('Done');\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "PageRank is an algorithm used by Google Search to rank websites in their search engine results.Before viewing this visualization, we recommend you give the E-Factory Page a read (link provided under References).The top-most view simulates a mini-internet: a web of connections. A directed edge from A to B means that web Page A provides a link to B. The next view will display the final ranks. We first calculate the no. of links a page has, i.e., its outgoing edges and display in the next view pane.The last visual is an array of arrays. From 0 (top of matrix) down to the Nth Node (bottom), each stores an array of the Nodes pointing to it.For eg-if the first line of Matrix says \"2 3 -1 -1 -1\", it means Web Page 2 and 3 have a link to Web Page 0. The -1s represent null (nothing).The bottom-most view is where you will see the logs as the algorithm progresses."
  }
}