{
  "algorithm": {
    "categoryKey": "greedy",
    "categoryName": "Greedy",
    "algorithmKey": "kruskals-minimum-spanning-tree",
    "algorithmName": "Kruskal's Minimum Spanning Tree",
    "files": [
      {
        "name": "README.md",
        "content": "# Kruskal's Minimum Spanning Tree\n\nKruskal's algorithm is a minimum-spanning-tree algorithm which\nfinds an edge of the least possible weight that connects any two\ntrees in the forest. It is a greedy algorithm in graph theory\nas it finds a minimum spanning tree for a connected weighted\ngraph adding increasing cost arcs at each step. This means it\nfinds a subset of the edges that forms a tree that includes every\nvertex, where the total weight of all the edges in the tree is\nminimized. If the graph is not connected, then it finds a\nminimum spanning forest (a minimum spanning tree for each\nconnected component).\n\n![Kruskal Algorithm](https://upload.wikimedia.org/wikipedia/commons/5/5c/MST_kruskal_en.gif)\n\n![Kruskal Demo](https://upload.wikimedia.org/wikipedia/commons/b/bb/KruskalDemo.gif)\n\nA demo for Kruskal's algorithm based on Euclidean distance.\n\n## Minimum Spanning Tree\n\nA **minimum spanning tree** (MST) or minimum weight spanning tree\nis a subset of the edges of a connected, edge-weighted\n(un)directed graph that connects all the vertices together,\nwithout any cycles and with the minimum possible total edge\nweight. That is, it is a spanning tree whose sum of edge weights\nis as small as possible. More generally, any edge-weighted\nundirected graph (not necessarily connected) has a minimum\nspanning forest, which is a union of the minimum spanning\ntrees for its connected components.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/d/d2/Minimum_spanning_tree.svg)\n\nA planar graph and its minimum spanning tree. Each edge is\nlabeled with its weight, which here is roughly proportional\nto its length.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/c/c9/Multiple_minimum_spanning_trees.svg)\n\nThis figure shows there may be more than one minimum spanning\ntree in a graph. In the figure, the two trees below the graph\nare two possibilities of minimum spanning tree of the given graph.\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/kruskal)\n- [Minimum Spanning Tree on Wikipedia](https://en.wikipedia.org/wiki/Minimum_spanning_tree)\n- [Kruskal's Algorithm on Wikipedia](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm)\n- [Kruskal's Algorithm on YouTube by Tushar Roy](https://www.youtube.com/watch?v=fAuF0EuZVCk&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Kruskal's Algorithm on YouTube by Michael Sambol](https://www.youtube.com/watch?v=71UQH7Pr9kU&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "Gerhut",
            "avatar_url": "https://avatars.githubusercontent.com/u/2500247?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst tracer = new GraphTracer().directed(false).weighted();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\n/* let G = [ // G[i][j] indicates the weight of the path from the i-th node to the j-th node\n [0, 3, 0, 1, 0],\n [5, 0, 1, 2, 4],\n [1, 0, 0, 2, 0],\n [0, 2, 0, 0, 1],\n [0, 1, 3, 0, 0]\n ]; */\nconst G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction kruskal() {\n  const vcount = G.length;\n\n  // Preprocess: sort edges by weight.\n  const edges = [];\n  for (let vi = 0; vi < vcount - 1; vi++) {\n    for (let vj = vi + 1; vj < vcount; vj++) {\n      edges.push({\n        0: vi,\n        1: vj,\n        weight: G[vi][vj],\n      });\n    }\n  }\n  edges.sort((ei, ej) => ei.weight - ej.weight);\n\n  // Give each vertex a tree to decide if they are already in the same tree.\n  const t = [];\n  for (let i = 0; i < vcount; i++) {\n    t[i] = {};\n    t[i][i] = true;\n  }\n\n  let wsum = 0;\n  for (let n = 0; n < vcount - 1 && edges.length > 0;) {\n    const e = edges.shift(); // Get the edge of min weight\n    // visualize {\n    tracer.visit(e[0], e[1]);\n    Tracer.delay();\n    // }\n    if (t[e[0]] === t[e[1]]) {\n      // e[0] & e[1] already in the same tree, ignore\n      // visualize {\n      tracer.leave(e[0], e[1]);\n      Tracer.delay();\n      // }\n      continue;\n    }\n\n    // Choose the current edge.\n    wsum += e.weight;\n\n    // Merge tree of e[0] & e[1]\n    const tmerged = {};\n    for (const i in t[e[0]]) tmerged[i] = true;\n    for (const i in t[e[1]]) tmerged[i] = true;\n    for (const i in tmerged) t[i] = tmerged;\n\n    n += 1;\n  }\n\n  // logger {\n  logger.println(`The sum of all edges is: ${wsum}`);\n  // }\n}\n\nkruskal();\n",
        "contributors": [
          {
            "login": "Gerhut",
            "avatar_url": "https://avatars.githubusercontent.com/u/2500247?v=4"
          },
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      }
    ],
    "description": "Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component)."
  }
}