<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-78128848-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-78128848-1")</script><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#393939"><meta name="description" content="Interactive Algorithm Visualization" data-react-helmet="true"/><meta property="og:image" content="https://raw.githubusercontent.com/algorithm-visualizer/algorithm-visualizer/master/branding/screenshot.png"/><meta property="og:site_name" content="Algorithm Visualizer"/><link rel="shortcut icon" href="./favicon.png" type="image/png"><link rel="manifest" href="./manifest.json"><link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet"><title>Algorithm Visualizer</title><link href="./static/css/main.a8f1148f.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div><script>window.__PRELOADED_ALGORITHM__={
    "categoryKey": "brute-force",
    "categoryName": "Brute Force",
    "algorithmKey": "bubble-sort",
    "algorithmName": "Bubble Sort",
    "files": [
      {
        "name": "Code.java",
        "content": "import org.algorithm_visualizer.*;\n\nimport java.util.Arrays;\n\npublic class Main {\n\n    private static ChartTracer chartTracer = new ChartTracer();\n\n    private static LogTracer logTracer = new LogTracer(\"Console\");\n\n    private static Integer [] array = (Integer[]) new Randomize.Array1D(15, new Randomize.Integer(1, 20)).create();\n\n    public static void main(String[] args) {\n\n        int length = array.length;\n\n        logTracer.printf(\"original array = %s\\n\",Arrays.toString(array));\n        chartTracer.set(array);\n        Layout.setRoot(new VerticalLayout(new Commander[]{chartTracer, logTracer}));\n        Tracer.delay();\n\n        boolean flag;\n\n        for (int i = length - 1; i > 0; i--) {\n            flag = true;\n            for (int j = 0; j < i; j++) {\n                chartTracer.select(j);\n                chartTracer.select(j + 1);\n                Tracer.delay();\n                if (array[j] > array[j + 1]) {\n                    logTracer.printf(\"swap %s and %s\\n\",array[j],array[j + 1]);\n                    swap(j, j + 1, array);\n                    flag = false;\n                }\n                chartTracer.deselect(j);\n                chartTracer.deselect(j + 1);\n            }\n            if (flag) {\n                break;\n            }\n        }\n\n\n        logTracer.printf(\"sorted array = %s\\n\",Arrays.toString(array));\n\n    }\n\n    private static void swap(int x, int y, Integer [] array) {\n        int temp = array[x];\n        array[x] = array[y];\n        array[y] = temp;\n        chartTracer.patch(x, array[x]);\n        chartTracer.patch(y, array[y]);\n        Tracer.delay();\n        chartTracer.depatch(x);\n        chartTracer.depatch(y);\n    }\n\n}\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          }
        ]
      },
      {
        "name": "README.md",
        "content": "# Bubble Sort\n\nBubble sort, sometimes referred to as sinking sort, is a\nsimple sorting algorithm that repeatedly steps through\nthe list to be sorted, compares each pair of adjacent\nitems and swaps them if they are in the wrong order\n(ascending or descending arrangement). The pass through\nthe list is repeated until no swaps are needed, which\nindicates that the list is sorted.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Bubble sort**       | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Yes       |           |\n\n## References\n\n- [trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/bubble-sort)\n- [Wikipedia](https://en.wikipedia.org/wiki/Bubble_sort)\n- [YouTube](https://www.youtube.com/watch?v=6Gv8vg0kcHc&index=27&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "nadr0",
            "avatar_url": "https://avatars.githubusercontent.com/u/1581329?v=4"
          }
        ]
      },
      {
        "name": "code.js",
        "content": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15 });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\n// logger {\nlogger.println(`original array = [${D.join(', ')}]`);\n// }\nlet N = D.length;\nlet swapped;\ndo {\n  swapped = false;\n  // visualize {\n  tracer.select(N - 1);\n  Tracer.delay();\n  // }\n  for (let i = 1; i < N; i++) {\n    // visualize {\n    tracer.select(i);\n    Tracer.delay();\n    // }\n    if (D[i - 1] > D[i]) {\n      // logger {\n      logger.println(`swap ${D[i - 1]} and ${D[i]}`);\n      // }\n      const temp = D[i - 1];\n      D[i - 1] = D[i];\n      D[i] = temp;\n      swapped = true;\n      // visualize {\n      tracer.patch(i - 1, D[i - 1]);\n      tracer.patch(i, D[i]);\n      Tracer.delay();\n      tracer.depatch(i - 1);\n      tracer.depatch(i);\n      // }\n    }\n    // visualize {\n    tracer.deselect(i);\n    // }\n  }\n  // visualize {\n  tracer.deselect(N - 1);\n  // }\n  N--;\n} while (swapped);\n// logger {\nlogger.println(`sorted array = [${D.join(', ')}]`);\n// }\n",
        "contributors": [
          {
            "login": "64json",
            "avatar_url": "https://avatars.githubusercontent.com/u/1618732?v=4"
          },
          {
            "login": "TornjV",
            "avatar_url": "https://avatars.githubusercontent.com/u/13820300?v=4"
          },
          {
            "login": "Yee172",
            "avatar_url": "https://avatars.githubusercontent.com/u/29087644?v=4"
          }
        ]
      },
      {
        "name": "main.cpp",
        "content": "#include \"algorithm-visualizer.h\"\n\n#define N   15\n#define MIN 1\n#define MAX 20\n\nvoid BubbleSort(int start, int end, int array[]);\n\nChartTracer chartTracer(\"Chart\");\n\nint main() {\n    int array[N];\n    Randomize::Array1D<int>(N, *(new Randomize::Integer(MIN, MAX))).fill(&array[0]);\n    chartTracer.set(array);\n    Layout::setRoot(VerticalLayout({ chartTracer }));\n\n    BubbleSort(0, N - 1, array);\n\n    return 0;\n}\n\nvoid BubbleSort(int start, int end, int array[])\n{\n    chartTracer.select(end);\n\n    int newEnd = start;\n    for(int i = start; i < end; ++i)\n    {\n        chartTracer.select(i);\n        chartTracer.select(i + 1);\n        Tracer::delay();\n        if(array[i] > array[i + 1])\n        {\n            std::swap(array[i], array[i + 1]);\n            chartTracer.patch(i, array[i]);\n            chartTracer.patch(i + 1, array[i + 1]);\n            Tracer::delay();\n            chartTracer.depatch(i);\n            chartTracer.depatch(i + 1);\n            newEnd = i;\n        }\n\n        chartTracer.deselect(i);\n        chartTracer.deselect(i + 1);\n    }\n\n    if(newEnd == start)\n    {\n        return;\n    }\n    else\n    {\n        BubbleSort(start, newEnd, array);\n    }\n}\n",
        "contributors": []
      }
    ],
    "description": "Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order (ascending or descending arrangement). The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted."
}</script><script>!function(l){function e(e){for(var r,t,n=e[0],o=e[1],u=e[2],f=0,i=[];f<n.length;f++)t=n[f],p[t]&&i.push(p[t][0]),p[t]=0;for(r in o)Object.prototype.hasOwnProperty.call(o,r)&&(l[r]=o[r]);for(s&&s(e);i.length;)i.shift()();return c.push.apply(c,u||[]),a()}function a(){for(var e,r=0;r<c.length;r++){for(var t=c[r],n=!0,o=1;o<t.length;o++){var u=t[o];0!==p[u]&&(n=!1)}n&&(c.splice(r--,1),e=f(f.s=t[0]))}return e}var t={},p={1:0},c=[];function f(e){if(t[e])return t[e].exports;var r=t[e]={i:e,l:!1,exports:{}};return l[e].call(r.exports,r,r.exports,f),r.l=!0,r.exports}f.m=l,f.c=t,f.d=function(e,r,t){f.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},f.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},f.t=function(r,e){if(1&e&&(r=f(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(f.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var n in r)f.d(t,n,function(e){return r[e]}.bind(null,n));return t},f.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return f.d(r,"a",r),r},f.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},f.p="./";var r=window.webpackJsonp=window.webpackJsonp||[],n=r.push.bind(r);r.push=e,r=r.slice();for(var o=0;o<r.length;o++)e(r[o]);var s=n;a()}([])</script><script src="./static/js/2.99662475.chunk.js"></script><script src="./static/js/main.db9ef860.chunk.js"></script></body></html>